---
queries:
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Diagnostics/ExtractedFiles.ql
  relativeBqrsPath: codeql/python-queries/Diagnostics/ExtractedFiles.bqrs
  metadata:
    name: Extracted Python files
    description: Lists all Python files in the source code directory that were extracted.
    kind: diagnostic
    id: py/diagnostics/successfully-extracted-files
    tags: successfully-extracted-files
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Diagnostics/ExtractionWarnings.ql
  relativeBqrsPath: codeql/python-queries/Diagnostics/ExtractionWarnings.bqrs
  metadata:
    name: Python extraction warnings
    description: List all extraction warnings for Python files in the source code
      directory.
    kind: diagnostic
    id: py/diagnostics/extraction-warnings
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Expressions/UseofInput.ql
  relativeBqrsPath: codeql/python-queries/Expressions/UseofInput.bqrs
  metadata:
    name: '''input'' function used in Python 2'
    description: "The built-in function 'input' is used which, in Python 2, can allow\
      \ arbitrary code to be run."
    kind: problem
    tags: |-
      security
             correctness
             external/cwe/cwe-094
             external/cwe/cwe-095
    problem.severity: error
    security-severity: 9.8
    sub-severity: high
    precision: high
    id: py/use-of-input
  queryHelp: |
    # 'input' function used in Python 2
    In Python 2, a call to the `input()` function, `input(prompt)` is equivalent to `eval(raw_input(prompt))`. Evaluating user input without any checking can be a serious security flaw.


    ## Recommendation
    Get user input with `raw_input(prompt)` and then validate that input before evaluating. If the expected input is a number or string, then `ast.literal_eval()` can always be used safely.


    ## References
    * Python Standard Library: [input](http://docs.python.org/2/library/functions.html#input), [ast.literal_eval](http://docs.python.org/2/library/ast.html#ast.literal_eval).
    * Wikipedia: [Data validation](http://en.wikipedia.org/wiki/Data_validation).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CVE-2018-1281/BindToAllInterfaces.ql
  relativeBqrsPath: codeql/python-queries/Security/CVE-2018-1281/BindToAllInterfaces.bqrs
  metadata:
    name: Binding a socket to all network interfaces
    description: |-
      Binding a socket to all interfaces opens it up to traffic from any IPv4 address
       and is therefore associated with security risks.
    kind: problem
    tags: |-
      security
             external/cwe/cwe-200
    problem.severity: error
    security-severity: 6.5
    sub-severity: low
    precision: high
    id: py/bind-socket-all-network-interfaces
  queryHelp: |
    # Binding a socket to all network interfaces
    Sockets can be used to communicate with other machines on a network. You can use the (IP address, port) pair to define the access restrictions for the socket you create. When using the built-in Python `socket` module (for instance, when building a message sender service or an FTP server data transmitter), one has to bind the port to some interface. When you bind the port to all interfaces using `0.0.0.0` as the IP address, you essentially allow it to accept connections from any IPv4 address provided that it can get to the socket via routing. Binding to all interfaces is therefore associated with security risks.


    ## Recommendation
    Bind your service incoming traffic only to a dedicated interface. If you need to bind more than one interface using the built-in `socket` module, create multiple sockets (instead of binding to one socket to all interfaces).


    ## Example
    In this example, two sockets are insecure because they are bound to all interfaces; one through the `0.0.0.0` notation and another one through an empty string `''`.


    ```python
    import socket

    # binds to all interfaces, insecure
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('0.0.0.0', 31137))

    # binds to all interfaces, insecure
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('', 4040))

    # binds only to a dedicated interface, secure
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('84.68.10.12', 8080))

    ```

    ## References
    * Python reference: [ Socket families](https://docs.python.org/3/library/socket.html#socket-families).
    * Python reference: [ Socket Programming HOWTO](https://docs.python.org/3.7/howto/sockets.html).
    * Common Vulnerabilities and Exposures: [ CVE-2018-1281 Detail](https://nvd.nist.gov/vuln/detail/CVE-2018-1281).
    * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/CookieInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/CookieInjection.bqrs
  metadata:
    name: Construction of a cookie using user-supplied input
    description: Constructing cookies from user input may allow an attacker to perform
      a Cookie Poisoning attack.
    kind: path-problem
    problem.severity: warning
    precision: high
    security-severity: 5.0
    id: py/cookie-injection
    tags: |-
      security
             external/cwe/cwe-020
  queryHelp: |
    # Construction of a cookie using user-supplied input
    Constructing cookies from user input can allow an attacker to control a user's cookie. This may lead to a session fixation attack. Additionally, client code may not expect a cookie to contain attacker-controlled data, and fail to sanitize it for common vulnerabilities such as Cross Site Scripting (XSS). An attacker manipulating the raw cookie header may additionally be able to set cookie attributes such as `HttpOnly` to insecure values.


    ## Recommendation
    Do not use raw user input to construct cookies.


    ## Example
    In the following cases, a cookie is constructed for a Flask response using user input. The first uses `set_cookie`, and the second sets a cookie's raw value through the `set-cookie` header.


    ```python
    from flask import request, make_response


    @app.route("/1")
    def set_cookie():
        resp = make_response()
        resp.set_cookie(request.args["name"], # BAD: User input is used to set the cookie's name and value
                        value=request.args["name"])
        return resp


    @app.route("/2")
    def set_cookie_header():
        resp = make_response()
        resp.headers['Set-Cookie'] = f"{request.args['name']}={request.args['name']};" # BAD: User input is used to set the raw cookie header.
        return resp

    ```

    ## References
    * Wikipedia - [Session Fixation](https://en.wikipedia.org/wiki/Session_fixation).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteHostnameRegExp.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/IncompleteHostnameRegExp.bqrs
  metadata:
    name: Incomplete regular expression for hostnames
    description: Matching a URL or hostname against a regular expression that contains
      an unescaped dot as part of the hostname might match more hostnames than expected.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: py/incomplete-hostname-regexp
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete regular expression for hostnames
    Sanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.

    If a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.


    ## Recommendation
    Escape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.


    ```python
    from flask import Flask, request, redirect
    import re

    app = Flask(__name__)

    UNSAFE_REGEX = re.compile("(www|beta).example.com/")
    SAFE_REGEX = re.compile(r"(www|beta)\.example\.com/")

    @app.route('/some/path/bad')
    def unsafe(request):
        target = request.args.get('target', '')
        if UNSAFE_REGEX.match(target):
            return redirect(target)

    @app.route('/some/path/good')
    def safe(request):
        target = request.args.get('target', '')
        if SAFE_REGEX.match(target):
            return redirect(target)

    ```
    The `unsafe` check is easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.

    The `safe` check closes this vulnerability by escaping the `.` so that URLs of the form `wwwXexample.com` are rejected.


    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/IncompleteUrlSubstringSanitization.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/IncompleteUrlSubstringSanitization.bqrs
  metadata:
    name: Incomplete URL substring sanitization
    description: Security checks on the substrings of an unparsed URL are often vulnerable
      to bypassing.
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: py/incomplete-url-substring-sanitization
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Incomplete URL substring sanitization
    Sanitizing untrusted URLs is a common technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.

    However, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.

    Even if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.


    ## Recommendation
    Parse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.


    ## Example
    The following example code checks that a URL redirection will reach the `example.com` domain.


    ```python
    from flask import Flask, request, redirect
    from urllib.parse import urlparse

    app = Flask(__name__)

    # Not safe, as "evil-example.net/example.com" would be accepted

    @app.route('/some/path/bad1')
    def unsafe1(request):
        target = request.args.get('target', '')
        if "example.com" in target:
            return redirect(target)

    # Not safe, as "benign-looking-prefix-example.com" would be accepted

    @app.route('/some/path/bad2')
    def unsafe2(request):
        target = request.args.get('target', '')
        if target.endswith("example.com"):
            return redirect(target)



    #Simplest and safest approach is to use an allowlist

    @app.route('/some/path/good1')
    def safe1(request):
        allowlist = [
            "example.com/home",
            "example.com/login",
        ]
        target = request.args.get('target', '')
        if target in allowlist:
            return redirect(target)

    #More complex example allowing sub-domains.

    @app.route('/some/path/good2')
    def safe2(request):
        target = request.args.get('target', '')
        host = urlparse(target).hostname
        #Note the '.' preceding example.com
        if host and host.endswith(".example.com"):
            return redirect(target)


    ```
    The first two examples show unsafe checks that are easily bypassed. In `unsafe1` the attacker can simply add `example.com` anywhere in the url. For example, `http://evil-example.net/example.com`.

    In `unsafe2` the attacker must use a hostname ending in `example.com`, but that is easy to do. For example, `http://benign-looking-prefix-example.com`.

    The second two examples show safe checks. In `safe1`, an allowlist is used. Although fairly inflexible, this is easy to get right and is most likely to be safe.

    In `safe2`, `urlparse` is used to parse the URL, then the hostname is checked to make sure it ends with `.example.com`.


    ## References
    * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
    * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-020/OverlyLargeRange.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-020/OverlyLargeRange.bqrs
  metadata:
    name: Overly permissive regular expression range
    description: |-
      Overly permissive regular expression ranges match a wider range of characters than intended.
                    This may allow an attacker to bypass a filter or sanitizer.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: py/overly-large-range
    tags: |-
      correctness
             security
             external/cwe/cwe-020
  queryHelp: |
    # Overly permissive regular expression range
    It's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \ ] ^ _ ` ``.

    Another common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.


    ## Recommendation
    Avoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.


    ## Example
    The following example code is intended to check whether a string is a valid 6 digit hex color.

    ```python

    import re
    def is_valid_hex_color(color):
        return re.match(r'^#[0-9a-fA-f]{6}$', color) is not None

    ```
    However, the `A-f` range is overly large and matches every uppercase character. It would parse a "color" like `#XXYYZZ` as valid.

    The fix is to use an uppercase `A-F` range instead.

    ```python

    import re
    def is_valid_hex_color(color):
        return re.match(r'^#[0-9a-fA-F]{6}$', color) is not None

    ```

    ## References
    * GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)
    * wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)
    * Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)
    * Paul Boyd: [The regex \[,-.\]](https://pboyd.io/posts/comma-dash-dot/)
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-022/PathInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-022/PathInjection.bqrs
  metadata:
    name: Uncontrolled data used in path expression
    description: Accessing paths influenced by users can allow an attacker to access
      unexpected resources.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    sub-severity: high
    precision: high
    id: py/path-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-022
             external/cwe/cwe-023
             external/cwe/cwe-036
             external/cwe/cwe-073
             external/cwe/cwe-099
  queryHelp: |
    # Uncontrolled data used in path expression
    Accessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.


    ## Recommendation
    Validate user input before using it to construct a file path, either using an off-the-shelf library function like `werkzeug.utils.secure_filename`, or by performing custom validation.

    Ideally, follow these rules:

    * Do not allow more than a single "." character.
    * Do not allow directory separators such as "/" or "\\" (depending on the file system).
    * Do not rely on simply replacing problematic sequences such as "../". For example, after applying this filter to ".../...//", the resulting string would still be "../".
    * Use an allowlist of known good patterns.

    ## Example
    In the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name that is an absolute path, such as `"/etc/passwd"`.

    In the second example, it appears that the user is restricted to opening a file within the `"user"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `"../../../etc/passwd"` will result in the code reading the file located at `"/server/static/images/../../../etc/passwd"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords. Note that a user could also use an absolute path here, since the result of `os.path.join("/server/static/images/", "/etc/passwd")` is `"/etc/passwd"`.

    In the third example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.


    ```python
    import os.path
    from flask import Flask, request, abort

    app = Flask(__name__)

    @app.route("/user_picture1")
    def user_picture1():
        filename = request.args.get('p')
        # BAD: This could read any file on the file system
        data = open(filename, 'rb').read()
        return data

    @app.route("/user_picture2")
    def user_picture2():
        base_path = '/server/static/images'
        filename = request.args.get('p')
        # BAD: This could still read any file on the file system
        data = open(os.path.join(base_path, filename), 'rb').read()
        return data

    @app.route("/user_picture3")
    def user_picture3():
        base_path = '/server/static/images'
        filename = request.args.get('p')
        #GOOD -- Verify with normalised version of path
        fullpath = os.path.normpath(os.path.join(base_path, filename))
        if not fullpath.startswith(base_path):
            raise Exception("not allowed")
        data = open(fullpath, 'rb').read()
        return data

    ```

    ## References
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * npm: [werkzeug.utils.secure_filename](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
    * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
    * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
    * Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-022/TarSlip.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-022/TarSlip.bqrs
  metadata:
    name: Arbitrary file write during tarfile extraction
    description: |-
      Extracting files from a malicious tar archive without validating that the
                    destination file path is within the destination directory can cause files outside
                    the destination directory to be overwritten.
    kind: path-problem
    id: py/tarslip
    problem.severity: error
    security-severity: 7.5
    precision: medium
    tags: |-
      security
             external/cwe/cwe-022
  queryHelp: |
    # Arbitrary file write during tarfile extraction
    Extracting files from a malicious tar archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten, due to the possible presence of directory traversal elements (`..`) in archive paths.

    Tar archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to determine an output file to write the contents of the archive item to, then the file may be written to an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.

    For example, if a tar archive contains a file entry `..\sneaky-file`, and the tar archive is extracted to the directory `c:\output`, then naively combining the paths would result in an output file path of `c:\output\..\sneaky-file`, which would cause the file to be written to `c:\sneaky-file`.


    ## Recommendation
    Ensure that output paths constructed from tar archive entries are validated to prevent writing files to unexpected locations.

    The recommended way of writing an output file from a tar archive entry is to check that `".."` does not occur in the path.


    ## Example
    In this example an archive is extracted without validating file paths. If `archive.tar` contained relative paths (for instance, if it were created by something like `tar -cf archive.tar ../file.txt`) then executing this code could write to locations outside the destination directory.


    ```python
    import sys
    import tarfile

    with tarfile.open(sys.argv[1]) as tar:
        #BAD : This could write any file on the filesystem.
        for entry in tar:
            tar.extract(entry, "/tmp/unpack/")

    ```
    To fix this vulnerability, we need to check that the path does not contain any `".."` elements in it.


    ```python
    import sys
    import tarfile
    import os.path

    with tarfile.open(sys.argv[1]) as tar:
        for entry in tar:
            #GOOD: Check that entry is safe
            if os.path.isabs(entry.name) or ".." in entry.name:
                raise ValueError("Illegal tar archive entry")
            tar.extract(entry, "/tmp/unpack/")

    ```

    ## References
    * Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).
    * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
    * Python Library Reference: [TarFile.extract](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extract).
    * Python Library Reference: [TarFile.extractall](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extractall).
    * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-074/TemplateInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-074/TemplateInjection.bqrs
  metadata:
    name: Server Side Template Injection
    description: Using user-controlled data to create a template can lead to remote
      code execution or cross site scripting.
    kind: path-problem
    problem.severity: error
    precision: high
    security-severity: 9.3
    id: py/template-injection
    tags: |-
      security
             external/cwe/cwe-074
  queryHelp: "# Server Side Template Injection\nA template from a server templating\
    \ engine such as Jinja constructed from user input can allow the user to execute\
    \ arbitrary code using certain template features. It can also allow for cross-site\
    \ scripting.\n\n\n## Recommendation\nEnsure that an untrusted value is not used\
    \ to directly construct a template. Jinja also provides `SandboxedEnvironment`\
    \ that prohibits access to unsafe methods and attributes. This can be used if\
    \ constructing a template from user input is absolutely necessary.\n\n\n## Example\n\
    In the following case, `template` is used to generate a Jinja2 template string.\
    \ This can lead to remote code execution.\n\n\n```python\nfrom django.urls import\
    \ path\nfrom django.http import HttpResponse\nfrom jinja2 import Template, escape\n\
    \n\ndef a(request):\n    template = request.GET['template']\n\n    # BAD: Template\
    \ is constructed from user input. \n    t = Template(template)\n\n    name = request.GET['name']\n\
    \    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns\
    \ = [\n    path('a', a),\n]\n```\nThe following is an example of a string that\
    \ could be used to cause remote code execution when interpreted as a template:\n\
    \n\n```txt\n{% for s in ().__class__.__base__.__subclasses__() %}{% if \"warning\"\
    \ in s.__name__ %}{{s()._module.__builtins__['__import__']('os').system('cat /etc/passwd')\
    \ }}{% endif %}{% endfor %}\n\n```\nIn the following case, user input is not used\
    \ to construct the template. Instead, it is only used as the parameters to render\
    \ the template, which is safe.\n\n\n```python\nfrom django.urls import path\n\
    from django.http import HttpResponse\nfrom jinja2 import Template, escape\n\n\n\
    def a(request):\n    # GOOD: Template is a constant, not constructed from user\
    \ input\n    t = Template(\"Hello, {{name}}!\")\n\n    name = request.GET['name']\n\
    \    html = t.render(name=escape(name))\n    return HttpResponse(html)\n\n\nurlpatterns\
    \ = [\n    path('a', a),\n]\n```\nIn the following case, a `SandboxedEnvironment`\
    \ is used, preventing remote code execution.\n\n\n```python\nfrom django.urls\
    \ import path\nfrom django.http import HttpResponse\nfrom jinja2 import escape\n\
    from jinja2.sandbox import SandboxedEnvironment\n\n\ndef a(request):\n    env\
    \ = SandboxedEnvironment()\n    template = request.GET['template']\n\n    # GOOD:\
    \ A sandboxed environment is used to construct the template. \n    t = env.from_string(template)\n\
    \n    name = request.GET['name']\n    html = t.render(name=escape(name))\n   \
    \ return HttpResponse(html)\n\n\nurlpatterns = [\n    path('a', a),\n]\n```\n\n\
    ## References\n* Portswigger: [Server-Side Template Injection](https://portswigger.net/web-security/server-side-template-injection).\n\
    * Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-078/CommandInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-078/CommandInjection.bqrs
  metadata:
    name: Uncontrolled command line
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    sub-severity: high
    precision: high
    id: py/command-line-injection
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
  queryHelp: |
    # Uncontrolled command line
    Code that passes user input directly to `exec`, `eval`, or some other library routine that executes a command, allows the user to execute malicious code.


    ## Recommendation
    If possible, use hard-coded string literals to specify the command to run or the library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

    If the applicable libraries or commands cannot be determined at compile time, then add code to verify that the user input string is safe before using it.


    ## Example
    The following example shows two functions. The first is unsafe as it takes a shell script that can be changed by a user, and passes it straight to `subprocess.call()` without examining it first. The second is safe as it selects the command from a predefined allowlist.


    ```python

    urlpatterns = [
        # Route to command_execution
        url(r'^command-ex1$', command_execution_unsafe, name='command-execution-unsafe'),
        url(r'^command-ex2$', command_execution_safe, name='command-execution-safe')
    ]

    COMMANDS = {
        "list" :"ls",
        "stat" : "stat"
    }

    def command_execution_unsafe(request):
        if request.method == 'POST':
            action = request.POST.get('action', '')
            #BAD -- No sanitizing of input
            subprocess.call(["application", action])

    def command_execution_safe(request):
        if request.method == 'POST':
            action = request.POST.get('action', '')
            #GOOD -- Use an allowlist
            subprocess.call(["application", COMMANDS[action]])

    ```

    ## References
    * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-078/UnsafeShellCommandConstruction.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-078/UnsafeShellCommandConstruction.bqrs
  metadata:
    name: Unsafe shell command constructed from library input
    description: |-
      Using externally controlled strings in a command line may allow a malicious
                    user to change the meaning of the command.
    kind: path-problem
    problem.severity: error
    security-severity: 6.3
    precision: medium
    id: py/shell-command-constructed-from-input
    tags: |-
      correctness
             security
             external/cwe/cwe-078
             external/cwe/cwe-088
             external/cwe/cwe-073
  queryHelp: "# Unsafe shell command constructed from library input\nDynamically constructing\
    \ a shell command with inputs from library functions may inadvertently change\
    \ the meaning of the shell command. Clients using the exported function may use\
    \ inputs containing characters that the shell interprets in a special way, for\
    \ instance quotes and spaces. This can result in the shell command misbehaving,\
    \ or even allowing a malicious user to execute arbitrary commands on the system.\n\
    \n\n## Recommendation\nIf possible, provide the dynamic arguments to the shell\
    \ as an array to APIs such as `subprocess.run` to avoid interpretation by the\
    \ shell.\n\nAlternatively, if the shell command must be constructed dynamically,\
    \ then add code to ensure that special characters do not alter the shell command\
    \ unexpectedly.\n\n\n## Example\nThe following example shows a dynamically constructed\
    \ shell command that downloads a file from a remote URL.\n\n\n```python\nimport\
    \ os\n\ndef download(path): \n    os.system(\"wget \" + path) # NOT OK\n\n```\n\
    The shell command will, however, fail to work as intended if the input contains\
    \ spaces or other special characters interpreted in a special way by the shell.\n\
    \nEven worse, a client might pass in user-controlled data, not knowing that the\
    \ input is interpreted as a shell command. This could allow a malicious user to\
    \ provide the input `http://example.org; cat /etc/passwd` in order to execute\
    \ the command `cat /etc/passwd`.\n\nTo avoid such potentially catastrophic behaviors,\
    \ provide the input from library functions as an argument that does not get interpreted\
    \ by a shell:\n\n\n```python\nimport subprocess\n\ndef download(path): \n    subprocess.run([\"\
    wget\", path]) # OK\n\n```\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n\
    * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n\
    * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n\
    * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-079/Jinja2WithoutEscaping.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-079/Jinja2WithoutEscaping.bqrs
  metadata:
    name: Jinja2 templating with autoescape=False
    description: |-
      Using jinja2 templates with 'autoescape=False' can
                    cause a cross-site scripting vulnerability.
    kind: problem
    problem.severity: error
    security-severity: 6.1
    precision: medium
    id: py/jinja2/autoescape-false
    tags: |-
      security
             external/cwe/cwe-079
  queryHelp: |
    # Jinja2 templating with autoescape=False
    Cross-site scripting (XSS) attacks can occur if untrusted input is not escaped. This applies to templates as well as code. The `jinja2` templates may be vulnerable to XSS if the environment has `autoescape` set to `False`. Unfortunately, `jinja2` sets `autoescape` to `False` by default. Explicitly setting `autoescape` to `True` when creating an `Environment` object will prevent this.


    ## Recommendation
    Avoid setting jinja2 autoescape to False. Jinja2 provides the function `select_autoescape` to make sure that the correct auto-escaping is chosen. For example, it can be used when creating an environment `Environment(autoescape=select_autoescape(['html', 'xml'])`


    ## Example
    The following example is a minimal Flask app which shows a safe and an unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.


    ```python
    from flask import Flask, request, make_response, escape
    from jinja2 import Environment, select_autoescape, FileSystemLoader

    app = Flask(__name__)
    loader = FileSystemLoader( searchpath="templates/" )

    unsafe_env = Environment(loader=loader)
    safe1_env = Environment(loader=loader, autoescape=True)
    safe2_env = Environment(loader=loader, autoescape=select_autoescape())

    def render_response_from_env(env):
        name = request.args.get('name', '')
        template = env.get_template('template.html')
        return make_response(template.render(name=name))

    @app.route('/unsafe')
    def unsafe():
        return render_response_from_env(unsafe_env)

    @app.route('/safe1')
    def safe1():
        return render_response_from_env(safe1_env)

    @app.route('/safe2')
    def safe2():
        return render_response_from_env(safe2_env)


    ```

    ## References
    * Jinja2: [API](http://jinja.pocoo.org/docs/2.10/api/).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-079/ReflectedXss.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-079/ReflectedXss.bqrs
  metadata:
    name: Reflected server-side cross-site scripting
    description: |-
      Writing user input directly to a web page
                    allows for a cross-site scripting vulnerability.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    sub-severity: high
    precision: high
    id: py/reflective-xss
    tags: |-
      security
             external/cwe/cwe-079
             external/cwe/cwe-116
  queryHelp: |
    # Reflected server-side cross-site scripting
    Directly writing user input (for example, an HTTP request parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.


    ## Recommendation
    To guard against cross-site scripting, consider escaping the input before writing user input to the page. The standard library provides escaping functions: `html.escape()` for Python 3.2 upwards or `cgi.escape()` older versions of Python. Most frameworks also provide their own escaping functions, for example `flask.escape()`.


    ## Example
    The following example is a minimal flask app which shows a safe and unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.


    ```python
    from flask import Flask, request, make_response, escape

    app = Flask(__name__)

    @app.route('/unsafe')
    def unsafe():
        first_name = request.args.get('name', '')
        return make_response("Your name is " + first_name)

    @app.route('/safe')
    def safe():
        first_name = request.args.get('name', '')
        return make_response("Your name is " + escape(first_name))

    ```

    ## References
    * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
    * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
    * Python Library Reference: [html.escape()](https://docs.python.org/3/library/html.html#html.escape).
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-089/SqlInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-089/SqlInjection.bqrs
  metadata:
    name: SQL query built from user-controlled sources
    description: |-
      Building a SQL query from user-controlled sources is vulnerable to insertion of
                    malicious SQL code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 8.8
    precision: high
    id: py/sql-injection
    tags: |-
      security
             external/cwe/cwe-089
  queryHelp: |
    # SQL query built from user-controlled sources
    If a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a user may be able to run malicious database queries.

    This also includes using the `TextClause` class in the `[SQLAlchemy](https://pypi.org/project/SQLAlchemy/)` PyPI package, which is used to represent a literal SQL fragment and is inserted directly into the final SQL when used in a query built using the ORM.


    ## Recommendation
    Most database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.


    ## Example
    In the following snippet, a user is fetched from the database using three different queries.

    In the first case, the query string is built by directly using string formatting from a user-supplied request parameter. The parameter may include quote characters, so this code is vulnerable to a SQL injection attack.

    In the second case, the user-supplied request attribute is passed to the database using query parameters. The database connector library will take care of escaping and inserting quotes as needed.

    In the third case, the placeholder in the SQL string has been manually quoted. Since most databaseconnector libraries will insert their own quotes, doing so yourself will make the code vulnerable to SQL injection attacks. In this example, if `username` was `; DROP ALL TABLES -- `, the final SQL query would be `SELECT * FROM users WHERE username = ''; DROP ALL TABLES -- ''`


    ```python
    from django.conf.urls import url
    from django.db import connection


    def show_user(request, username):
        with connection.cursor() as cursor:
            # BAD -- Using string formatting
            cursor.execute("SELECT * FROM users WHERE username = '%s'" % username)
            user = cursor.fetchone()

            # GOOD -- Using parameters
            cursor.execute("SELECT * FROM users WHERE username = %s", username)
            user = cursor.fetchone()

            # BAD -- Manually quoting placeholder (%s)
            cursor.execute("SELECT * FROM users WHERE username = '%s'", username)
            user = cursor.fetchone()

    urlpatterns = [url(r'^users/(?P<username>[^/]+)$', show_user)]

    ```

    ## References
    * Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
    * OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).
    * [SQLAlchemy documentation for TextClause](https://docs.sqlalchemy.org/en/14/core/sqlelement.html#sqlalchemy.sql.expression.text.params.text).
    * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-090/LdapInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-090/LdapInjection.bqrs
  metadata:
    name: LDAP query built from user-controlled sources
    description: |-
      Building an LDAP query from user-controlled sources is vulnerable to insertion of
                    malicious LDAP code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: py/ldap-injection
    tags: |-
      security
             external/cwe/cwe-090
  queryHelp: |
    # LDAP query built from user-controlled sources
    If an LDAP query or DN is built using string concatenation or string formatting, and the components of the concatenation include user input without any proper sanitization, a user is likely to be able to run malicious LDAP queries.


    ## Recommendation
    If user input must be included in an LDAP query or DN, it should be escaped to avoid a malicious user providing special characters that change the meaning of the query. In Python2, user input should be escaped with `ldap.dn.escape_dn_chars` or `ldap.filter.escape_filter_chars`, while in Python3, user input should be escaped with `ldap3.utils.dn.escape_rdn` or `ldap3.utils.conv.escape_filter_chars` depending on the component tainted by the user. A good practice is to escape filter characters that could change the meaning of the query (https://tools.ietf.org/search/rfc4515\#section-3).


    ## Example
    In the following examples, the code accepts both `username` and `dc` from the user, which it then uses to build a LDAP query and DN.

    The first and the second example uses the unsanitized user input directly in the search filter and DN for the LDAP query. A malicious user could provide special characters to change the meaning of these components, and search for a completely different set of values.


    ```python
    from flask import request, Flask
    import ldap


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        dn = "dc={}".format(unsafe_dc)
        search_filter = "(user={})".format(unsafe_filter)

        ldap_connection = ldap.initialize("ldap://127.0.0.1")
        user = ldap_connection.search_s(
            dn, ldap.SCOPE_SUBTREE, search_filter)

    ```

    ```python
    from flask import request, Flask
    import ldap3


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        dn = "dc={}".format(unsafe_dc)
        search_filter = "(user={})".format(unsafe_filter)

        srv = ldap3.Server('ldap://127.0.0.1')
        conn = ldap3.Connection(srv, user=dn, auto_bind=True)
        conn.search(dn, search_filter)

    ```
    In the third and fourth example, the input provided by the user is sanitized before it is included in the search filter or DN. This ensures the meaning of the query cannot be changed by a malicious user.


    ```python
    from flask import request, Flask
    import ldap
    import ldap.filter
    import ldap.dn


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        safe_dc = ldap.dn.escape_dn_chars(unsafe_dc)
        safe_filter = ldap.filter.escape_filter_chars(unsafe_filter)

        dn = "dc={}".format(safe_dc)
        search_filter = "(user={})".format(safe_filter)

        ldap_connection = ldap.initialize("ldap://127.0.0.1")
        user = ldap_connection.search_s(
            dn, ldap.SCOPE_SUBTREE, search_filter)

    ```

    ```python
    from flask import request, Flask
    import ldap3
    from ldap3.utils.dn import escape_rdn
    from ldap3.utils.conv import escape_filter_chars


    @app.route("/normal")
    def normal():
        unsafe_dc = request.args['dc']
        unsafe_filter = request.args['username']

        safe_dc = escape_rdn(unsafe_dc)
        safe_filter = escape_filter_chars(unsafe_filter)

        dn = "dc={}".format(safe_dc)
        search_filter = "(user={})".format(safe_filter)

        srv = ldap3.Server('ldap://127.0.0.1')
        conn = ldap3.Connection(srv, user=dn, auto_bind=True)
        conn.search(dn, search_filter)

    ```

    ## References
    * OWASP: [LDAP Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html).
    * OWASP: [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection).
    * SonarSource: [RSPEC-2078](https://rules.sonarsource.com/python/RSPEC-2078).
    * Python2: [LDAP Documentation](https://www.python-ldap.org/en/python-ldap-3.3.0/reference/ldap.html).
    * Python3: [LDAP Documentation](https://ldap3.readthedocs.io/en/latest/).
    * Wikipedia: [LDAP injection](https://en.wikipedia.org/wiki/LDAP_injection).
    * BlackHat: [LDAP Injection and Blind LDAP Injection](https://www.blackhat.com/presentations/bh-europe-08/Alonso-Parada/Whitepaper/bh-eu-08-alonso-parada-WP.pdf).
    * LDAP: [Understanding and Defending Against LDAP Injection Attacks](https://ldap.com/2018/05/04/understanding-and-defending-against-ldap-injection-attacks/).
    * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-094/CodeInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-094/CodeInjection.bqrs
  metadata:
    name: Code injection
    description: |-
      Interpreting unsanitized user input as code allows a malicious user to perform arbitrary
                    code execution.
    kind: path-problem
    problem.severity: error
    security-severity: 9.3
    sub-severity: high
    precision: high
    id: py/code-injection
    tags: |-
      security
             external/cwe/cwe-094
             external/cwe/cwe-095
             external/cwe/cwe-116
  queryHelp: |
    # Code injection
    Directly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is passed to code that interprets it as an expression to be evaluated, such as `eval` or `exec`.


    ## Recommendation
    Avoid including user input in any expression that may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.


    ## Example
    The following example shows two functions setting a name from a request. The first function uses `exec` to execute the `setname` function. This is dangerous as it can allow a malicious user to execute arbitrary code on the server. For example, the user could supply the value `"' + subprocess.call('rm -rf') + '"` to destroy the server's file system. The second function calls the `setname` function directly and is thus safe.


    ```python

    urlpatterns = [
        # Route to code_execution
        url(r'^code-ex1$', code_execution_bad, name='code-execution-bad'),
        url(r'^code-ex2$', code_execution_good, name='code-execution-good')
    ]

    def code_execution(request):
        if request.method == 'POST':
            first_name = base64.decodestring(request.POST.get('first_name', ''))
            #BAD -- Allow user to define code to be run.
            exec("setname('%s')" % first_name)

    def code_execution(request):
        if request.method == 'POST':
            first_name = base64.decodestring(request.POST.get('first_name', ''))
            #GOOD --Call code directly
            setname(first_name)

    ```

    ## References
    * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
    * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
    * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
    * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-113/HeaderInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-113/HeaderInjection.bqrs
  metadata:
    name: HTTP Response Splitting
    description: |-
      Writing user input directly to an HTTP header
                    makes code vulnerable to attack by header splitting.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    precision: high
    id: py/http-response-splitting
    tags: |-
      security
             external/cwe/cwe-113
             external/cwe/cwe-079
  queryHelp: "# HTTP Response Splitting\nDirectly writing user input (for example,\
    \ an HTTP request parameter) to an HTTP header can lead to an HTTP response-splitting\
    \ vulnerability.\n\nIf user-controlled input is used in an HTTP header that allows\
    \ line break characters, an attacker can inject additional headers or control\
    \ the response body, leading to vulnerabilities such as XSS or cache poisoning.\n\
    \n\n## Recommendation\nEnsure that user input containing line break characters\
    \ is not written to an HTTP header.\n\n\n## Example\nIn the following example,\
    \ the case marked BAD writes user input to the header name. In the GOOD case,\
    \ input is first escaped to not contain any line break characters.\n\n\n```python\n\
    @app.route(\"/example_bad\")\ndef example_bad():\n    rfs_header = request.args[\"\
    rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\"\
    \ + rfs_header\n    # BAD: User input is used as part of the header name.\n  \
    \  response.headers[custom_header] = \"HeaderValue\" \n    return response\n\n\
    @app.route(\"/example_good\")\ndef example_bad():\n    rfs_header = request.args[\"\
    rfs_header\"]\n    response = Response()\n    custom_header = \"X-MyHeader-\"\
    \ + rfs_header.replace(\"\\n\", \"\").replace(\"\\r\",\"\").replace(\":\",\"\"\
    )\n    # GOOD: Line break characters are removed from the input.\n    response.headers[custom_header]\
    \ = \"HeaderValue\" \n    return response\n```\n\n## References\n* SecLists.org:\
    \ [HTTP response splitting](https://seclists.org/bugtraq/2005/Apr/187).\n* OWASP:\
    \ [HTTP Response Splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting).\n\
    * Wikipedia: [HTTP response splitting](http://en.wikipedia.org/wiki/HTTP_response_splitting).\n\
    * CAPEC: [CAPEC-105: HTTP Request Splitting](https://capec.mitre.org/data/definitions/105.html)\n\
    * Common Weakness Enumeration: [CWE-113](https://cwe.mitre.org/data/definitions/113.html).\n\
    * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-116/BadTagFilter.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-116/BadTagFilter.bqrs
  metadata:
    name: Bad HTML filtering regexp
    description: "Matching HTML tags using regular expressions is hard to do right,\
      \ and can easily lead to security issues."
    kind: problem
    problem.severity: warning
    security-severity: 7.8
    precision: high
    id: py/bad-tag-filter
    tags: |-
      correctness
             security
             external/cwe/cwe-116
             external/cwe/cwe-020
             external/cwe/cwe-185
             external/cwe/cwe-186
  queryHelp: "# Bad HTML filtering regexp\nIt is possible to match some single HTML\
    \ tags using regular expressions (parsing general HTML using regular expressions\
    \ is impossible). However, if the regular expression is not written well it might\
    \ be possible to circumvent it, which can lead to cross-site scripting or other\
    \ security issues.\n\nSome of these mistakes are caused by browsers having very\
    \ forgiving HTML parsers, and will often render invalid HTML containing syntax\
    \ errors. Regular expressions that attempt to match HTML should also recognize\
    \ tags containing such syntax errors.\n\n\n## Recommendation\nUse a well-tested\
    \ sanitization or parser library if at all possible. These libraries are much\
    \ more likely to handle corner cases correctly than a custom implementation.\n\
    \n\n## Example\nThe following example attempts to filters out all `<script>` tags.\n\
    \n\n```python\nimport re\n\ndef filterScriptTags(content): \n    oldContent =\
    \ \"\"\n    while oldContent != content:\n        oldContent = content\n     \
    \   content = re.sub(r'<script.*?>.*?</script>', '', content, flags= re.DOTALL\
    \ | re.IGNORECASE)\n    return content\n```\nThe above sanitizer does not filter\
    \ out all `<script>` tags. Browsers will not only accept `</script>` as script\
    \ end tags, but also tags such as `</script foo=\"bar\">` even though it is a\
    \ parser error. This means that an attack string such as `<script>alert(1)</script\
    \ foo=\"bar\">` will not be filtered by the function, and `alert(1)` will be executed\
    \ by a browser if the string is rendered as HTML.\n\nOther corner cases include\
    \ that HTML comments can end with `--!>`, and that HTML tag names can contain\
    \ upper case characters.\n\n\n## References\n* Securitum: [The Curious Case of\
    \ Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).\n\
    * stackoverflow.com: [You can't parse \\[X\\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).\n\
    * HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).\n\
    * stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).\n\
    * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n\
    * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n\
    * Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).\n\
    * Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-117/LogInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-117/LogInjection.bqrs
  metadata:
    name: Log Injection
    description: |-
      Building log entries from user-controlled data is vulnerable to
                    insertion of forged log entries by a malicious user.
    kind: path-problem
    problem.severity: error
    security-severity: 7.8
    precision: medium
    id: py/log-injection
    tags: |-
      security
             external/cwe/cwe-117
  queryHelp: |
    # Log Injection
    If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

    Forgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user to create the appearance of multiple log entries. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.


    ## Recommendation
    User input should be suitably sanitized before it is logged.

    If the log entries are plain text then line breaks should be removed from user input, using for example `replace(old, new)` or similar. Care should also be taken that user input is clearly marked in log entries, and that a malicious user cannot cause confusion in other ways.

    For log entries that will be displayed in HTML, user input should be HTML encoded before being logged, to prevent forgery and other forms of HTML injection.


    ## Example
    In the example, the name provided by the user is recorded using the log output function (`logging.info` or `app.logger.info`, etc.). In these four cases, the name provided by the user is not provided The processing is recorded. If a malicious user provides `Guest%0D%0AUser name: Admin` as a parameter, the log entry will be divided into two lines, the first line is `User name: Guest` code&gt;, the second line is `User name: Admin`.


    ```python
    #!/usr/bin/env python
    # -*- coding: UTF-8 -*-
    """
    @Desc   ：Log Injection
    """
    from flask import Flask
    from flask import request
    from django.utils.log import request_logger
    import logging

    logging.basicConfig(level=logging.DEBUG)

    app = Flask(__name__)

    @app.route('/bad1')
    def bad1():
        name = request.args.get('name')
        app.logger.info('User name: ' + name) # Bad
        return 'bad1'

    @app.route('/bad2')
    def bad2():
        name = request.args.get('name')
        logging.info('User name: ' + name) # Bad
        return 'bad2'

    @app.route('/bad3')
    def bad3():
        name = request.args.get('name')
        request_logger.warn('User name: ' + name) # Bad
        return 'bad3'

    @app.route('/bad4')
    def bad4():
        name = request.args.get('name')
        logtest = logging.getLogger('test')
        logtest.debug('User name: ' + name) # Bad
        return 'bad4'

    if __name__ == '__main__':
        app.debug = True
        handler = logging.FileHandler('log')
        app.logger.addHandler(handler)
        app.run()

    ```
    In a good example, the program uses the `replace` function to provide parameter processing to the user, and replace `\r\n` and `\n` with empty characters. To a certain extent, the occurrence of log injection vulnerabilities is reduced.


    ```python
    #!/usr/bin/env python
    # -*- coding: UTF-8 -*-
    """
    @Desc   ：Log Injection
    """
    from flask import Flask
    from flask import request
    import logging

    logging.basicConfig(level=logging.DEBUG)

    app = Flask(__name__)

    @app.route('/good1')
    def good1():
        name = request.args.get('name')
        name = name.replace('\r\n','').replace('\n','')
        logging.info('User name: ' + name) # Good
        return 'good1'

    if __name__ == '__main__':
        app.debug = True
        handler = logging.FileHandler('log')
        app.logger.addHandler(handler)
        app.run()

    ```

    ## References
    * OWASP: [Log Injection](https://owasp.org/www-community/attacks/Log_Injection).
    * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-209/StackTraceExposure.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-209/StackTraceExposure.bqrs
  metadata:
    name: Information exposure through an exception
    description: |-
      Leaking information about an exception, such as messages and stack traces, to an
                    external user can expose implementation details that are useful to an attacker for
                    developing a subsequent exploit.
    kind: path-problem
    problem.severity: error
    security-severity: 5.4
    precision: high
    id: py/stack-trace-exposure
    tags: |-
      security
             external/cwe/cwe-209
             external/cwe/cwe-497
  queryHelp: |
    # Information exposure through an exception
    Software developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.

    Unfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.


    ## Recommendation
    Send the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.


    ## Example
    In the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user by returning it from the function. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server, and a generic error message is displayed to the user. That way, the developers can still access and use the error log, but remote users will not see the information.


    ```python
    from flask import Flask
    app = Flask(__name__)


    import traceback

    def do_computation():
        raise Exception("Secret info")

    # BAD
    @app.route('/bad')
    def server_bad():
        try:
            do_computation()
        except Exception as e:
            return traceback.format_exc()

    # GOOD
    @app.route('/good')
    def server_good():
        try:
            do_computation()
        except Exception as e:
            log(traceback.format_exc())
            return "An internal error has occurred!"

    ```

    ## References
    * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).
    * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).
    * Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-215/FlaskDebug.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-215/FlaskDebug.bqrs
  metadata:
    name: Flask app is run in debug mode
    description: Running a Flask app in debug mode may allow an attacker to run arbitrary
      code through the Werkzeug debugger.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/flask-debug
    tags: |-
      security
             external/cwe/cwe-215
             external/cwe/cwe-489
  queryHelp: |
    # Flask app is run in debug mode
    Running a Flask application with debug mode enabled may allow an attacker to gain access through the Werkzeug debugger.


    ## Recommendation
    Ensure that Flask applications that are run in a production environment have debugging disabled.


    ## Example
    Running the following code starts a Flask webserver that has debugging enabled. By visiting `/crash`, it is possible to gain access to the debugger, and run arbitrary code through the interactive debugger.


    ```python
    from flask import Flask

    app = Flask(__name__)

    @app.route('/crash')
    def main():
        raise Exception()

    app.run(debug=True)

    ```

    ## References
    * Flask Quickstart Documentation: [Debug Mode](http://flask.pocoo.org/docs/1.0/quickstart/#debug-mode).
    * Werkzeug Documentation: [Debugging Applications](http://werkzeug.pocoo.org/docs/0.14/debug/).
    * Common Weakness Enumeration: [CWE-215](https://cwe.mitre.org/data/definitions/215.html).
    * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-285/PamAuthorization.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-285/PamAuthorization.bqrs
  metadata:
    name: PAM authorization bypass due to incorrect usage
    description: Not using `pam_acct_mgmt` after `pam_authenticate` to check the validity
      of a login can lead to authorization bypass.
    kind: path-problem
    problem.severity: warning
    security-severity: 8.1
    precision: high
    id: py/pam-auth-bypass
    tags: |-
      security
             external/cwe/cwe-285
  queryHelp: |
    # PAM authorization bypass due to incorrect usage
    Using only a call to `pam_authenticate` to check the validity of a login can lead to authorization bypass vulnerabilities.

    A `pam_authenticate` only verifies the credentials of a user. It does not check if a user has an appropriate authorization to actually login. This means a user with an expired login or a password can still access the system.


    ## Recommendation
    A call to `pam_authenticate` should be followed by a call to `pam_acct_mgmt` to check if a user is allowed to login.


    ## Example
    In the following example, the code only checks the credentials of a user. Hence, in this case, a user with expired credentials can still login. This can be verified by creating a new user account, expiring it with ``` chage -E0 `username`  ``` and then trying to log in.


    ```python
    libpam                    = CDLL(find_library("pam"))

    pam_authenticate          = libpam.pam_authenticate
    pam_authenticate.restype  = c_int
    pam_authenticate.argtypes = [PamHandle, c_int]

    def authenticate(username, password, service='login'):
        def my_conv(n_messages, messages, p_response, app_data):
            """
            Simple conversation function that responds to any prompt where the echo is off with the supplied password
            """
            ...

        handle = PamHandle()
        conv   = PamConv(my_conv, 0)
        retval = pam_start(service, username, byref(conv), byref(handle))

        retval = pam_authenticate(handle, 0)
        return retval == 0

    ```
    This can be avoided by calling `pam_acct_mgmt` call to verify access as has been done in the snippet shown below.


    ```python
    libpam                    = CDLL(find_library("pam"))

    pam_authenticate          = libpam.pam_authenticate
    pam_authenticate.restype  = c_int
    pam_authenticate.argtypes = [PamHandle, c_int]

    pam_acct_mgmt          = libpam.pam_acct_mgmt
    pam_acct_mgmt.restype  = c_int
    pam_acct_mgmt.argtypes = [PamHandle, c_int]

    def authenticate(username, password, service='login'):
        def my_conv(n_messages, messages, p_response, app_data):
            """
            Simple conversation function that responds to any prompt where the echo is off with the supplied password
            """
            ...

        handle = PamHandle()
        conv   = PamConv(my_conv, 0)
        retval = pam_start(service, username, byref(conv), byref(handle))

        retval = pam_authenticate(handle, 0)
        if retval == 0:
            retval = pam_acct_mgmt(handle, 0)
        return retval == 0

    ```

    ## References
    * Man-Page: [pam_acct_mgmt](https://man7.org/linux/man-pages/man3/pam_acct_mgmt.3.html)
    * Common Weakness Enumeration: [CWE-285](https://cwe.mitre.org/data/definitions/285.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-295/MissingHostKeyValidation.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-295/MissingHostKeyValidation.bqrs
  metadata:
    name: Accepting unknown SSH host keys when using Paramiko
    description: Accepting unknown host keys can allow man-in-the-middle attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/paramiko-missing-host-key-validation
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: |
    # Accepting unknown SSH host keys when using Paramiko
    In the Secure Shell (SSH) protocol, host keys are used to verify the identity of remote hosts. Accepting unknown host keys may leave the connection open to man-in-the-middle attacks.


    ## Recommendation
    Do not accept unknown host keys. In particular, do not set the default missing host key policy for the Paramiko library to either `AutoAddPolicy` or `WarningPolicy`. Both of these policies continue even when the host key is unknown. The default setting of `RejectPolicy` is secure because it throws an exception when it encounters an unknown host key.


    ## Example
    The following example shows two ways of opening an SSH connection to `example.com`. The first function sets the missing host key policy to `AutoAddPolicy`. If the host key verification fails, the client will continue to interact with the server, even though the connection may be compromised. The second function sets the host key policy to `RejectPolicy`, and will throw an exception if the host key verification fails.


    ```python
    from paramiko.client import SSHClient, AutoAddPolicy, RejectPolicy

    def unsafe_connect():
        client = SSHClient()
        client.set_missing_host_key_policy(AutoAddPolicy)
        client.connect("example.com")

        # ... interaction with server

        client.close()

    def safe_connect():
        client = SSHClient()
        client.set_missing_host_key_policy(RejectPolicy)
        client.connect("example.com")

        # ... interaction with server

        client.close()

    ```

    ## References
    * Paramiko documentation: [set_missing_host_key_policy](http://docs.paramiko.org/en/2.4/api/client.html?highlight=set_missing_host_key_policy#paramiko.client.SSHClient.set_missing_host_key_policy).
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-295/RequestWithoutValidation.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-295/RequestWithoutValidation.bqrs
  metadata:
    name: Request without certificate validation
    description: Making a request without certificate validation can allow man-in-the-middle
      attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: medium
    id: py/request-without-cert-validation
    tags: |-
      security
             external/cwe/cwe-295
  queryHelp: |
    # Request without certificate validation
    Encryption is key to the security of most, if not all, online communication. Using Transport Layer Security (TLS) can ensure that communication cannot be interrupted by an interloper. For this reason, it is unwise to disable the verification that TLS provides. Functions in the `requests` module provide verification by default, and it is only when explicitly turned off using `verify=False` that no verification occurs.


    ## Recommendation
    Never use `verify=False` when making a request.


    ## Example
    The example shows two unsafe calls to [semmle.com](https://semmle.com), followed by various safe alternatives.


    ```python
    import requests

    #Unsafe requests

    requests.get('https://semmle.com', verify=False) # UNSAFE
    requests.get('https://semmle.com', verify=0) # UNSAFE

    #Various safe options

    requests.get('https://semmle.com', verify=True) # Explicitly safe
    requests.get('https://semmle.com', verify="/path/to/cert/")
    requests.get('https://semmle.com') # The default is to verify.

    #Wrapper to ensure safety

    def make_safe_request(url, verify_cert):
        if not verify_cert:
            raise Exception("Trying to make unsafe request")
        return requests.get(url, verify_cert)

    ```

    ## References
    * Python requests documentation: [SSL Cert Verification](https://requests.readthedocs.io/en/latest/user/advanced/#ssl-cert-verification).
    * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-312/CleartextLogging.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-312/CleartextLogging.bqrs
  metadata:
    name: Clear-text logging of sensitive information
    description: |-
      Logging sensitive information without encryption or hashing can
                    expose it to an attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/clear-text-logging-sensitive-data
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-359
             external/cwe/cwe-532
  queryHelp: |
    # Clear-text logging of sensitive information
    If sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.

    Potential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.


    ## Recommendation
    Sensitive data should not be logged.


    ## Example
    In the example the entire process environment is logged using \`print\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.


    ```python
    # BAD: Logging cleartext sensitive data
    import os
    print(f"[INFO] Environment: {os.environ}")
    ```
    In the second example the data that is logged is not sensitive.


    ```python
    not_sensitive_data = {'a': 1, 'b': 2}
    # GOOD: it is fine to log data that is not sensitive
    print(f"[INFO] Some object contains: {not_sensitive_data}")
    ```

    ## References
    * OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
    * Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-312/CleartextStorage.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-312/CleartextStorage.bqrs
  metadata:
    name: Clear-text storage of sensitive information
    description: |-
      Sensitive information stored without encryption or hashing can expose it to an
                    attacker.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/clear-text-storage-sensitive-data
    tags: |-
      security
             external/cwe/cwe-312
             external/cwe/cwe-315
             external/cwe/cwe-359
  queryHelp: |
    # Clear-text storage of sensitive information
    Sensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.


    ## Recommendation
    Ensure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.

    In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.

    Be aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.


    ## Example
    The following example code stores user credentials (in this case, their password) in a cookie in plain text:


    ```python
    from flask import Flask, make_response, request

    app = Flask("Leak password")

    @app.route('/')
    def index():
        password = request.args.get("password")
        resp = make_response(render_template(...))
        resp.set_cookie("password", password)
        return resp

    ```
    Instead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.


    ## References
    * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.
    * M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.
    * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
    * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
    * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-326/WeakCryptoKey.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-326/WeakCryptoKey.bqrs
  metadata:
    name: Use of weak cryptographic key
    description: Use of a cryptographic key that is too small may allow the encryption
      to be broken.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/weak-crypto-key
    tags: |-
      security
             external/cwe/cwe-326
  queryHelp: |
    # Use of weak cryptographic key
    Modern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.

    The three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.


    ## Recommendation
    Increase the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.


    ## References
    * Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).
    * Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).
    * Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).
    * Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).
    * NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/BrokenCryptoAlgorithm.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/BrokenCryptoAlgorithm.bqrs
  metadata:
    name: Use of a broken or weak cryptographic algorithm
    description: Using broken or weak cryptographic algorithms can compromise security.
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/weak-cryptographic-algorithm
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Use of a broken or weak cryptographic algorithm
    Using broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.

    Many cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.

    This query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.


    ## Recommendation
    Ensure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.


    ## Example
    The following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.


    ```python
    from Crypto.Cipher import DES, AES

    cipher = DES.new(SECRET_KEY)

    def send_encrypted(channel, message):
        channel.send(cipher.encrypt(message)) # BAD: weak encryption


    cipher = AES.new(SECRET_KEY)

    def send_encrypted(channel, message):
        channel.send(cipher.encrypt(message)) # GOOD: strong encryption


    ```
    NOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).


    ## References
    * NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).
    * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
    * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/InsecureDefaultProtocol.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/InsecureDefaultProtocol.bqrs
  metadata:
    name: Default version of SSL/TLS may be insecure
    description: |-
      Leaving the SSL/TLS version unspecified may result in an insecure
                    default protocol being used.
    id: py/insecure-default-protocol
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Default version of SSL/TLS may be insecure
    The `ssl.wrap_socket` function defaults to an insecure version of SSL/TLS when no specific protocol version is specified. This may leave the connection vulnerable to attack.


    ## Recommendation
    Ensure that a modern, strong protocol is used. All versions of SSL, and TLS 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended. If no explicit `ssl_version` is specified, the default `PROTOCOL_TLS` is chosen. This protocol is insecure because it allows TLS 1.0 and TLS 1.1 and so should not be used.


    ## Example
    The following code shows two different ways of setting up a connection using SSL or TLS. They are both potentially insecure because the default version is used.


    ```python
    import ssl
    import socket

    # Using the deprecated ssl.wrap_socket method
    ssl.wrap_socket(socket.socket())

    # Using SSLContext
    context = ssl.SSLContext()

    ```
    Both of the cases above should be updated to use a secure protocol instead, for instance by specifying `ssl_version=PROTOCOL_TLSv1_2` as a keyword argument.

    The latter example can also be made secure by modifying the created context before it is used to create a connection. Therefore it will not be flagged by this query. However, if a connection is created before the context has been secured (for example, by setting the value of `minimum_version`), then the code should be flagged by the query `py/insecure-protocol`.

    Note that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:

    * `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions
    * `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.
    Even when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \`minimum_version\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.


    ```python
    import ssl

    # Using flags to restrict the protocol
    context = ssl.SSLContext()
    context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1

    # Declaring a minimum version to restrict the protocol
    context = ssl.create_default_context()
    context.minimum_version = ssl.TLSVersion.TLSv1_2

    ```

    ## References
    * Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).
    * Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).
    * Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).
    * Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).
    * Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/InsecureProtocol.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/InsecureProtocol.bqrs
  metadata:
    name: Use of insecure SSL/TLS version
    description: Using an insecure SSL/TLS version may leave the connection vulnerable
      to attacks.
    id: py/insecure-protocol
    kind: problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    tags: |-
      security
             external/cwe/cwe-327
  queryHelp: |
    # Use of insecure SSL/TLS version
    Using a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.


    ## Recommendation
    Ensure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.


    ## Example
    The following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.


    ```python
    import ssl
    import socket

    # Using the deprecated ssl.wrap_socket method
    ssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)

    # Using SSLContext
    context = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)

    # Using pyOpenSSL

    from pyOpenSSL import SSL

    context = SSL.Context(SSL.TLSv1_METHOD)



    ```
    All cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.

    Note that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:

    * `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions
    * `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.
    Even when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \`minimum_version\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.


    ```python
    import ssl

    # Using flags to restrict the protocol
    context = ssl.SSLContext()
    context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1

    # Declaring a minimum version to restrict the protocol
    context = ssl.create_default_context()
    context.minimum_version = ssl.TLSVersion.TLSv1_2

    ```

    ## References
    * Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).
    * Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).
    * Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).
    * Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).
    * Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).
    * pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-327/WeakSensitiveDataHashing.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-327/WeakSensitiveDataHashing.bqrs
  metadata:
    name: Use of a broken or weak cryptographic hashing algorithm on sensitive data
    description: Using broken or weak cryptographic hashing algorithms can compromise
      security.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/weak-sensitive-data-hashing
    tags: |-
      security
             external/cwe/cwe-327
             external/cwe/cwe-328
             external/cwe/cwe-916
  queryHelp: |
    # Use of a broken or weak cryptographic hashing algorithm on sensitive data
    Using a broken or weak cryptographic hash function can leave data vulnerable, and should not be used in security related code.

    A strong cryptographic hash function should be resistant to:

    * pre-image attacks: if you know a hash value `h(x)`, you should not be able to easily find the input `x`.
    * collision attacks: if you know a hash value `h(x)`, you should not be able to easily find a different input `y` with the same hash value `h(x) = h(y)`.
    In cases with a limited input space, such as for passwords, the hash function also needs to be computationally expensive to be resistant to brute-force attacks. Passwords should also have an unique salt applied before hashing, but that is not considered by this query.

    As an example, both MD5 and SHA-1 are known to be vulnerable to collision attacks.

    Since it's OK to use a weak cryptographic hash function in a non-security context, this query only alerts when these are used to hash sensitive data (such as passwords, certificates, usernames).

    Use of broken or weak cryptographic algorithms that are not hashing algorithms, is handled by the `py/weak-cryptographic-algorithm` query.


    ## Recommendation
    Ensure that you use a strong, modern cryptographic hash function:

    * such as Argon2, scrypt, bcrypt, or PBKDF2 for passwords and other data with limited input space.
    * such as SHA-2, or SHA-3 in other cases.

    ## Example
    The following example shows two functions for checking whether the hash of a certificate matches a known value -- to prevent tampering. The first function uses MD5 that is known to be vulnerable to collision attacks. The second function uses SHA-256 that is a strong cryptographic hashing function.


    ```python
    import hashlib

    def certificate_matches_known_hash_bad(certificate, known_hash):
        hash = hashlib.md5(certificate).hexdigest() # BAD
        return hash == known_hash

    def certificate_matches_known_hash_good(certificate, known_hash):
        hash = hashlib.sha256(certificate).hexdigest() # GOOD
        return hash == known_hash

    ```

    ## Example
    The following example shows two functions for hashing passwords. The first function uses SHA-256 to hash passwords. Although SHA-256 is a strong cryptographic hash function, it is not suitable for password hashing since it is not computationally expensive.


    ```python
    import hashlib

    def get_password_hash(password: str, salt: str):
        return hashlib.sha256(password + salt).hexdigest() # BAD

    ```
    The second function uses Argon2 (through the `argon2-cffi` PyPI package), which is a strong password hashing algorithm (and includes a per-password salt by default).


    ```python
    from argon2 import PasswordHasher

    def get_initial_hash(password: str):
        ph = PasswordHasher()
        return ph.hash(password) # GOOD

    def check_password(password: str, known_hash):
        ph = PasswordHasher()
        return ph.verify(known_hash, password) # GOOD

    ```

    ## References
    * OWASP: [Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
    * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
    * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).
    * Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-352/CSRFProtectionDisabled.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-352/CSRFProtectionDisabled.bqrs
  metadata:
    name: CSRF protection weakened or disabled
    description: |-
      Disabling or weakening CSRF protection may make the application
                    vulnerable to a Cross-Site Request Forgery (CSRF) attack.
    kind: problem
    problem.severity: warning
    security-severity: 8.8
    precision: high
    id: py/csrf-protection-disabled
    tags: |-
      security
             external/cwe/cwe-352
  queryHelp: |
    # CSRF protection weakened or disabled
    Cross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.

    The attacker tricks an authenticated user into submitting a request to the web application. Typically this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.

    A common countermeasure for CSRF is to generate a unique token to be included in the HTML sent from the server to a user. This token can be used as a hidden field to be sent back with requests to the server, where the server can then check that the token is valid and associated with the relevant user session.


    ## Recommendation
    In many web frameworks, CSRF protection is enabled by default. In these cases, using the default configuration is sufficient to guard against most CSRF attacks.


    ## Example
    The following example shows a case where CSRF protection is disabled by overriding the default middleware stack and not including the one protecting against CSRF.


    ```python
    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        # 'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ```
    The protecting middleware was probably commented out during a testing phase, when server-side token generation was not set up. Simply commenting it back in will enable CSRF protection.


    ## References
    * Wikipedia: [Cross-site request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
    * OWASP: [Cross-site request forgery](https://owasp.org/www-community/attacks/csrf)
    * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-377/InsecureTemporaryFile.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-377/InsecureTemporaryFile.bqrs
  metadata:
    name: Insecure temporary file
    description: Creating a temporary file using this method may be insecure.
    kind: problem
    id: py/insecure-temporary-file
    problem.severity: error
    security-severity: 7.0
    sub-severity: high
    precision: high
    tags: |-
      external/cwe/cwe-377
             security
  queryHelp: |
    # Insecure temporary file
    Functions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.

    Note that `mktemp` has been deprecated since Python 2.3.


    ## Recommendation
    Replace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.


    ## Example
    The following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.


    ```python
    from tempfile import mktemp

    def write_results(results):
        filename = mktemp()
        with open(filename, "w+") as f:
            f.write(results)
        print("Results written to", filename)

    ```
    By changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.


    ```python
    from tempfile import NamedTemporaryFile

    def write_results(results):
        with NamedTemporaryFile(mode="w+", delete=False) as f:
            f.write(results)
        print("Results written to", f.name)

    ```

    ## References
    * Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).
    * Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-502/UnsafeDeserialization.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-502/UnsafeDeserialization.bqrs
  metadata:
    name: Deserialization of user-controlled data
    description: Deserializing user-controlled data may allow attackers to execute
      arbitrary code.
    kind: path-problem
    id: py/unsafe-deserialization
    problem.severity: error
    security-severity: 9.8
    sub-severity: high
    precision: high
    tags: |-
      external/cwe/cwe-502
             security
             serialization
  queryHelp: |
    # Deserialization of user-controlled data
    Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.

    There are many different serialization frameworks. This query currently supports Pickle, Marshal and Yaml.


    ## Recommendation
    Avoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON.

    If you need to use YAML, use the `yaml.safe_load` function.


    ## Example
    The following example calls `pickle.loads` directly on a value provided by an incoming HTTP request. Pickle then creates a new value from untrusted data, and is therefore inherently unsafe.


    ```python

    from django.conf.urls import url
    import pickle

    def unsafe(pickled):
        return pickle.loads(pickled)

    urlpatterns = [
        url(r'^(?P<object>.*)$', unsafe)
    ]
    ```
    Changing the code to use `json.loads` instead of `pickle.loads` removes the vulnerability.


    ```python

    from django.conf.urls import url
    import json

    def safe(pickled):
        return json.loads(pickled)

    urlpatterns = [
        url(r'^(?P<object>.*)$', safe)
    ]

    ```

    ## References
    * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
    * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
    * Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/)
    * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-601/UrlRedirect.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-601/UrlRedirect.bqrs
  metadata:
    name: URL redirection from remote source
    description: |-
      URL redirection based on unvalidated user input
                    may cause redirection to malicious web sites.
    kind: path-problem
    problem.severity: error
    security-severity: 6.1
    sub-severity: low
    id: py/url-redirection
    tags: |-
      security
             external/cwe/cwe-601
    precision: high
  queryHelp: |
    # URL redirection from remote source
    Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


    ## Recommendation
    To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.

    If this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL does not include an explicit host name.


    ## Example
    The following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:


    ```python
    from flask import Flask, request, redirect

    app = Flask(__name__)

    @app.route('/')
    def hello():
        target = request.args.get('target', '')
        return redirect(target, code=302)

    ```
    If you know the set of valid redirect targets, you can maintain a list of them on the server and check that the user input is in that list:


    ```python
    from flask import Flask, request, redirect

    VALID_REDIRECT = "http://cwe.mitre.org/data/definitions/601.html"

    app = Flask(__name__)

    @app.route('/')
    def hello():
        target = request.args.get('target', '')
        if target == VALID_REDIRECT:
            return redirect(target, code=302)
        else:
            # ignore the target and redirect to the home page
            return redirect('/', code=302)

    ```
    Often this is not possible, so an alternative is to check that the target URL does not specify an explicit host name. For example, you can use the `urlparse` function from the Python standard library to parse the URL and check that the `netloc` attribute is empty.

    Note, however, that some cases are not handled as we desire out-of-the-box by `urlparse`, so we need to adjust two things, as shown in the example below:

    * Many browsers accept backslash characters (`\`) as equivalent to forward slash characters (`/`) in URLs, but the `urlparse` function does not.
    * Mistyped URLs such as `https:/example.com` or `https:///example.com` are parsed as having an empty `netloc` attribute, while browsers will still redirect to the correct site.

    ```python
    from flask import Flask, request, redirect
    from urllib.parse import urlparse

    app = Flask(__name__)

    @app.route('/')
    def hello():
        target = request.args.get('target', '')
        target = target.replace('\\', '')
        if not urlparse(target).netloc and not urlparse(target).scheme:
            # relative path, safe to redirect
            return redirect(target, code=302)
        # ignore the target and redirect to the home page
        return redirect('/', code=302)

    ```
    For Django application, you can use the function `url_has_allowed_host_and_scheme` to check that a URL is safe to redirect to, as shown in the following example:


    ```python
    from django.http import HttpResponseRedirect
    from django.shortcuts import redirect
    from django.utils.http import url_has_allowed_host_and_scheme
    from django.views import View

    class RedirectView(View):
        def get(self, request, *args, **kwargs):
            target = request.GET.get('target', '')
            if url_has_allowed_host_and_scheme(target, allowed_hosts=None):
                return HttpResponseRedirect(target)
            else:
                # ignore the target and redirect to the home page
                return redirect('/')
    ```
    Note that `url_has_allowed_host_and_scheme` handles backslashes correctly, so no additional processing is required.


    ## References
    * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
    * Python standard library: [ urllib.parse](https://docs.python.org/3/library/urllib.parse.html).
    * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-611/Xxe.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-611/Xxe.bqrs
  metadata:
    name: XML external entity expansion
    description: |-
      Parsing user input as an XML document with external
                    entity expansion is vulnerable to XXE attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: py/xxe
    tags: |-
      security
             external/cwe/cwe-611
             external/cwe/cwe-827
  queryHelp: |
    # XML external entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.


    ## Recommendation
    The easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of the XML libraries in the standard library of Python 3, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.

    We recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).


    ## Example
    The following example uses the `lxml` XML parser to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to an XXE attack, since the [ default parser](https://lxml.de/apidoc/lxml.etree.html#lxml.etree.XMLParser) from `lxml.etree` allows local external entities to be resolved.


    ```python
    from flask import Flask, request
    import lxml.etree

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        doc = lxml.etree.fromstring(xml_src)
        return lxml.etree.tostring(doc)

    ```
    To guard against XXE attacks with the `lxml` library, you should create a parser with `resolve_entities` set to `false`. This means that no entity expansion is undertaken, although standard predefined entities such as `&gt;`, for writing `>` inside the text of an XML element, are still allowed.


    ```python
    from flask import Flask, request
    import lxml.etree

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        parser = lxml.etree.XMLParser(resolve_entities=False)
        doc = lxml.etree.fromstring(xml_src, parser=parser)
        return lxml.etree.tostring(doc)

    ```

    ## References
    * OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
    * Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).
    * Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
    * Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).
    * Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).
    * PortSwigger: [XML external entity (XXE) injection](https://portswigger.net/web-security/xxe).
    * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
    * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-614/InsecureCookie.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-614/InsecureCookie.bqrs
  metadata:
    name: Failure to use secure cookies
    description: |-
      Insecure cookies may be sent in cleartext, which makes them vulnerable to
                    interception.
    kind: problem
    problem.severity: warning
    security-severity: 5.0
    precision: high
    id: py/insecure-cookie
    tags: |-
      security
             external/cwe/cwe-614
             external/cwe/cwe-1004
             external/cwe/cwe-1275
  queryHelp: "# Failure to use secure cookies\nCookies without the `Secure` flag set\
    \ may be transmitted using HTTP instead of HTTPS, which leaves them vulnerable\
    \ to reading by a third party.\n\nCookies without the `HttpOnly` flag set are\
    \ accessible to JavaScript running in the same origin. In case of a Cross-Site\
    \ Scripting (XSS) vulnerability, the cookie can be stolen by a malicious script.\n\
    \nCookies with the `SameSite` attribute set to `'None'` will be sent with cross-origin\
    \ requests, which can be controlled by third-party JavaScript code and allow for\
    \ Cross-Site Request Forgery (CSRF) attacks.\n\n\n## Recommendation\nAlways set\
    \ `secure` to `True` or add \"; Secure;\" to the cookie's raw value.\n\nAlways\
    \ set `httponly` to `True` or add \"; HttpOnly;\" to the cookie's raw value.\n\
    \nAlways set `samesite` to `Lax` or `Strict`, or add \"; SameSite=Lax;\", or \"\
    ; Samesite=Strict;\" to the cookie's raw header value.\n\n\n## Example\nIn the\
    \ following examples, the cases marked GOOD show secure cookie attributes being\
    \ set; whereas in the cases marked BAD they are not set.\n\n\n```python\nfrom\
    \ flask import Flask, request, make_response, Response\n\n\n@app.route(\"/good1\"\
    )\ndef good1():\n    resp = make_response()\n    resp.set_cookie(\"name\", value=\"\
    value\", secure=True, httponly=True, samesite='Strict') # GOOD: Attributes are\
    \ securely set\n    return resp\n\n\n@app.route(\"/good2\")\ndef good2():\n  \
    \  resp = make_response()\n    resp.headers['Set-Cookie'] = \"name=value; Secure;\
    \ HttpOnly; SameSite=Strict\" # GOOD: Attributes are securely set \n    return\
    \ resp\n\n@app.route(\"/bad1\")\n    resp = make_response()\n    resp.set_cookie(\"\
    name\", value=\"value\", samesite='None') # BAD: the SameSite attribute is set\
    \ to 'None' and the 'Secure' and 'HttpOnly' attributes are set to False by default.\n\
    \    return resp\n```\n\n## References\n* Detectify: [Cookie lack Secure flag](https://support.detectify.com/support/solutions/articles/48001048982-cookie-lack-secure-flag).\n\
    * PortSwigger: [TLS cookie without secure flag set](https://portswigger.net/kb/issues/00500200_tls-cookie-without-secure-flag-set).\n\
    * Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).\n\
    * Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).\n\
    * Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-643/XpathInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-643/XpathInjection.bqrs
  metadata:
    name: XPath query built from user-controlled sources
    description: |-
      Building a XPath query from user-controlled sources is vulnerable to insertion of
                    malicious Xpath code by the user.
    kind: path-problem
    problem.severity: error
    security-severity: 9.8
    precision: high
    id: py/xpath-injection
    tags: |-
      security
             external/cwe/cwe-643
  queryHelp: |
    # XPath query built from user-controlled sources
    If an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.


    ## Recommendation
    If user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.


    ## Example
    In the example below, the xpath query is controlled by the user and hence leads to a vulnerability.


    ```python
    from lxml import etree
    from io import StringIO

    from django.urls import path
    from django.http import HttpResponse
    from django.template import Template, Context, Engine, engines


    def a(request):
        value = request.GET['xpath']
        f = StringIO('<foo><bar></bar></foo>')
        tree = etree.parse(f)
        r = tree.xpath("/tag[@id='%s']" % value)


    urlpatterns = [
        path('a', a)
    ]

    ```
    This can be fixed by using a parameterized query as shown below.


    ```python
    from lxml import etree
    from io import StringIO

    from django.urls import path
    from django.http import HttpResponse
    from django.template import Template, Context, Engine, engines


    def a(request):
        value = request.GET['xpath']
        f = StringIO('<foo><bar></bar></foo>')
        tree = etree.parse(f)
        r = tree.xpath("/tag[@id=$tagid]", tagid=value)


    urlpatterns = [
        path('a', a)
    ]

    ```

    ## References
    * OWASP XPath injection : [](https://owasp.org/www-community/attacks/XPATH_Injection)/&gt;&gt;
    * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-730/PolynomialReDoS.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-730/PolynomialReDoS.bqrs
  metadata:
    name: Polynomial regular expression used on uncontrolled data
    description: |-
      A regular expression that can require polynomial time
                    to match may be vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/polynomial-redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: "# Polynomial regular expression used on uncontrolled data\nSome regular\
    \ expressions take a long time to match certain input strings to the point where\
    \ the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>*\
    \ or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance,\
    \ or even allow a malicious user to perform a Denial of Service (\"DoS\") attack\
    \ by crafting an expensive input string for the regular expression to match.\n\
    \nThe regular expression engine provided by Python uses a backtracking non-deterministic\
    \ finite automata to implement regular expression matching. While this approach\
    \ is space-efficient and allows supporting advanced features like capture groups,\
    \ it is not time-efficient in general. The worst-case time complexity of such\
    \ an automaton can be polynomial or even exponential, meaning that for strings\
    \ of a certain shape, increasing the input length by ten characters may make the\
    \ automaton about 1000 times slower.\n\nTypically, a regular expression is affected\
    \ by this problem if it contains a repetition of the form `r*` or `r+` where the\
    \ sub-expression `r` is ambiguous in the sense that it can match some string in\
    \ multiple ways. More information about the precise circumstances can be found\
    \ in the references.\n\n\n## Recommendation\nModify the regular expression to\
    \ remove the ambiguity, or ensure that the strings matched with the regular expression\
    \ are short enough that the time-complexity does not matter.\n\n\n## Example\n\
    Consider this use of a regular expression, which removes all leading and trailing\
    \ whitespace in a string:\n\n```python\n\nre.sub(r\"^\\s+|\\s+$\", \"\", text)\
    \ # BAD\n```\nThe sub-expression `\"\\s+$\"` will match the whitespace characters\
    \ in `text` from left to right, but it can start matching anywhere within a whitespace\
    \ sequence. This is problematic for strings that do **not** end with a whitespace\
    \ character. Such a string will force the regular expression engine to process\
    \ each whitespace sequence once per whitespace character in the sequence.\n\n\
    This ultimately means that the time cost of trimming a string is quadratic in\
    \ the length of the string. So a string like `\"a b\"` will take milliseconds\
    \ to process, but a similar string with a million spaces instead of just one will\
    \ take several minutes.\n\nAvoid this problem by rewriting the regular expression\
    \ to not contain the ambiguity about when to start matching whitespace sequences.\
    \ For instance, by using a negative look-behind (`^\\s+|(?<!\\s)\\s+$`), or just\
    \ by using the built-in strip method (`text.strip()`).\n\nNote that the sub-expression\
    \ `\"^\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression\
    \ can start matching, and as the regular expression engine matches from left to\
    \ right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider\
    \ the regular expression that matches lines with numbers, possibly written using\
    \ scientific notation:\n\n```python\n\n^0\\.\\d+E?\\d+$ # BAD\n```\nThe problem\
    \ with this regular expression is in the sub-expression `\\d+E?\\d+` because the\
    \ second `\\d+` can start matching digits anywhere after the first match of the\
    \ first `\\d+` if there is no `E` in the input string.\n\nThis is problematic\
    \ for strings that do **not** end with a digit. Such a string will force the regular\
    \ expression engine to process each digit sequence once per digit in the sequence,\
    \ again leading to a quadratic time complexity.\n\nTo make the processing faster,\
    \ the regular expression should be rewritten such that the two `\\d+` sub-expressions\
    \ do not have overlapping matches: `^0\\.\\d+(E\\d+)?$`.\n\n\n## Example\nSometimes\
    \ it is unclear how a regular expression can be rewritten to avoid the problem.\
    \ In such cases, it often suffices to limit the length of the input string. For\
    \ instance, the following regular expression is used to match numbers, and on\
    \ some non-number inputs it can have quadratic time complexity:\n\n```python\n\
    \nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$', str)\
    \ \n```\nIt is not immediately obvious how to rewrite this regular expression\
    \ to avoid the problem. However, you can mitigate performance issues by limiting\
    \ the length to 1000 characters, which will always finish in a reasonable amount\
    \ of time.\n\n```python\n\nif len(str) > 1000:\n    raise ValueError(\"Input too\
    \ long\")\n\nmatch = re.search(r'^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\\
    d+)?$', str) \n```\n\n## References\n* OWASP: [Regular expression Denial of Service\
    \ - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n\
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time\
    \ complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage,\
    \ Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service\
    \ Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n\
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n\
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-730/ReDoS.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-730/ReDoS.bqrs
  metadata:
    name: Inefficient regular expression
    description: |-
      A regular expression that requires exponential time to match certain inputs
                    can be a performance bottleneck, and may be vulnerable to denial-of-service
                    attacks.
    kind: problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/redos
    tags: |-
      security
             external/cwe/cwe-1333
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Inefficient regular expression
    Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

    The regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

    Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


    ## Recommendation
    Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


    ## Example
    Consider this regular expression:

    ```python

    ^_(__|.)+_$
    ```
    Its sub-expression `"(__|.)+?"` can match the string `"__"` either by the first alternative `"__"` to the left of the `"|"` operator, or by two repetitions of the second alternative `"."` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.

    This problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:

    ```python

    ^_(__|[^_])+_$
    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
    * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
    * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-730/RegexInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-730/RegexInjection.bqrs
  metadata:
    name: Regular expression injection
    description: |-
      User input should not be used in regular expressions without first being escaped,
                    otherwise a malicious user may be able to inject an expression that could require
                    exponential time on certain inputs.
    kind: path-problem
    problem.severity: error
    security-severity: 7.5
    precision: high
    id: py/regex-injection
    tags: |-
      security
             external/cwe/cwe-730
             external/cwe/cwe-400
  queryHelp: |
    # Regular expression injection
    Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


    ## Recommendation
    Before embedding user input into a regular expression, use a sanitization function such as `re.escape` to escape meta-characters that have a special meaning regarding regular expressions' syntax.


    ## Example
    The following examples are based on a simple Flask web server environment.

    The following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:


    ```python
    from flask import request, Flask
    import re


    @app.route("/direct")
    def direct():
        unsafe_pattern = request.args["pattern"]
        re.search(unsafe_pattern, "")


    @app.route("/compile")
    def compile():
        unsafe_pattern = request.args["pattern"]
        compiled_pattern = re.compile(unsafe_pattern)
        compiled_pattern.search("")

    ```
    Instead, the request parameter should be sanitized first, for example using the function `re.escape`. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


    ```python
    from flask import request, Flask
    import re


    @app.route("/direct")
    def direct():
        unsafe_pattern = request.args['pattern']
        safe_pattern = re.escape(unsafe_pattern)
        re.search(safe_pattern, "")


    @app.route("/compile")
    def compile():
        unsafe_pattern = request.args['pattern']
        safe_pattern = re.escape(unsafe_pattern)
        compiled_pattern = re.compile(safe_pattern)
        compiled_pattern.search("")

    ```

    ## References
    * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
    * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
    * Python docs: [re](https://docs.python.org/3/library/re.html).
    * SonarSource: [RSPEC-2631](https://rules.sonarsource.com/python/type/Vulnerability/RSPEC-2631).
    * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-732/WeakFilePermissions.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-732/WeakFilePermissions.bqrs
  metadata:
    name: Overly permissive file permissions
    description: Allowing files to be readable or writable by users other than the
      owner may allow sensitive information to be accessed.
    kind: problem
    id: py/overly-permissive-file
    problem.severity: warning
    security-severity: 7.8
    sub-severity: high
    precision: medium
    tags: |-
      external/cwe/cwe-732
             security
  queryHelp: |
    # Overly permissive file permissions
    When creating a file, POSIX systems allow permissions to be specified for owner, group and others separately. Permissions should be kept as strict as possible, preventing access to the files contents by other users.


    ## Recommendation
    Restrict the file permissions of files to prevent any but the owner being able to read or write to that file


    ## References
    * Wikipedia: [File system permissions](https://en.wikipedia.org/wiki/File_system_permissions).
    * Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-776/XmlBomb.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-776/XmlBomb.bqrs
  metadata:
    name: XML internal entity expansion
    description: |-
      Parsing user input as an XML document with arbitrary internal
                    entity expansion is vulnerable to denial-of-service attacks.
    kind: path-problem
    problem.severity: warning
    security-severity: 7.5
    precision: high
    id: py/xml-bomb
    tags: |-
      security
             external/cwe/cwe-776
             external/cwe/cwe-400
  queryHelp: |
    # XML internal entity expansion
    Parsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.

    In XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.

    If untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.


    ## Recommendation
    The safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. Whether this can be done depends on the library being used. Note that some libraries, such as `lxml`, have measures enabled by default to prevent such DoS XML attacks, so unless you have explicitly set `huge_tree` to `True`, no further action is needed.

    We recommend using the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package, which has been created to prevent XML attacks (both XXE and XML bombs).


    ## Example
    The following example uses the `xml.etree` XML parser provided by the Python standard library to parse a string `xml_src`. That string is from an untrusted source, so this code is vulnerable to a DoS attack, since the `xml.etree` XML parser expands internal entities by default:


    ```python
    from flask import Flask, request
    import xml.etree.ElementTree as ET

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        doc = ET.fromstring(xml_src)
        return ET.tostring(doc)

    ```
    It is not possible to guard against internal entity expansion with `xml.etree`, so to guard against these attacks, the following example uses the [defusedxml](https://pypi.org/project/defusedxml/) PyPI package instead, which is not exposed to such internal entity expansion attacks.


    ```python
    from flask import Flask, request
    import defusedxml.ElementTree as ET

    app = Flask(__name__)

    @app.post("/upload")
    def upload():
        xml_src = request.get_data()
        doc = ET.fromstring(xml_src)
        return ET.tostring(doc)

    ```

    ## References
    * Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).
    * Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).
    * Python 3 standard library: [XML Vulnerabilities](https://docs.python.org/3/library/xml.html#xml-vulnerabilities).
    * Python 2 standard library: [XML Vulnerabilities](https://docs.python.org/2/library/xml.html#xml-vulnerabilities).
    * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
    * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-918/FullServerSideRequestForgery.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-918/FullServerSideRequestForgery.bqrs
  metadata:
    name: Full server-side request forgery
    description: Making a network request to a URL that is fully user-controlled allows
      for request forgery attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: high
    id: py/full-ssrf
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Full server-side request forgery
    Directly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.

    We make a distinctions between how much of the URL an attacker can control:

    * **Full SSRF**: where the full URL can be controlled.
    * **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.


    Partial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.

    This query covers full SSRF, to find partial SSRF use the `py/partial-ssrf` query.


    ## Recommendation
    To guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.


    ## Example
    The following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/full_ssrf")
    def full_ssrf():
        target = request.args["target"]

        # BAD: user has full control of URL
        resp = requests.get("https://" + target + ".example.com/data/")

        # GOOD: `subdomain` is controlled by the server.
        subdomain = "europe" if target == "EU" else "world"
        resp = requests.get("https://" + subdomain + ".example.com/data/")

    ```

    ## Example
    The following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/partial_ssrf")
    def partial_ssrf():
        user_id = request.args["user_id"]

        # BAD: user can fully control the path component of the URL
        resp = requests.get("https://api.example.com/user_info/" + user_id)

        if user_id.isalnum():
            # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL
            resp = requests.get("https://api.example.com/user_info/" + user_id)

    ```

    ## References
    * [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)
    * [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-918/PartialServerSideRequestForgery.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-918/PartialServerSideRequestForgery.bqrs
  metadata:
    name: Partial server-side request forgery
    description: Making a network request to a URL that is partially user-controlled
      allows for request forgery attacks.
    kind: path-problem
    problem.severity: error
    security-severity: 9.1
    precision: medium
    id: py/partial-ssrf
    tags: |-
      security
             external/cwe/cwe-918
  queryHelp: |
    # Partial server-side request forgery
    Directly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the request may be changed, directed at a different server, or via a different protocol. This can allow the attacker to obtain sensitive information or perform actions with escalated privilege.

    We make a distinctions between how much of the URL an attacker can control:

    * **Full SSRF**: where the full URL can be controlled.
    * **Partial SSRF**: where only part of the URL can be controlled, such as the path component of a URL to a hardcoded domain.


    Partial control of a URL is often much harder to exploit. Therefore we have created a separate query for each of these.

    This query covers partial SSRF, to find full SSRF use the `py/full-ssrf` query.


    ## Recommendation
    To guard against SSRF attacks you should avoid putting user-provided input directly into a request URL. On the application level, maintain a list of authorized URLs on the server and choose from that list based on the input provided. If that is not possible, one should verify the IP address for all user-controlled requests to ensure they are not private. This requires saving the verified IP address of each domain, then utilizing a custom HTTP adapter to ensure that future requests to that domain use the verified IP address. On the network level, you can segment the vulnerable application into its own LAN or block access to specific devices.


    ## Example
    The following example shows code vulnerable to a full SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `evil.com#` as the `target` value, the requested URL will be `https://evil.com#.example.com/data/`. It also shows how to remedy the problem by using the user input select a known fixed string.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/full_ssrf")
    def full_ssrf():
        target = request.args["target"]

        # BAD: user has full control of URL
        resp = requests.get("https://" + target + ".example.com/data/")

        # GOOD: `subdomain` is controlled by the server.
        subdomain = "europe" if target == "EU" else "world"
        resp = requests.get("https://" + subdomain + ".example.com/data/")

    ```

    ## Example
    The following example shows code vulnerable to a partial SSRF attack, because it uses untrusted input (HTTP request parameter) directly to construct a URL. By using `../transfer-funds-to/123?amount=456` as the `user_id` value, the requested URL will be `https://api.example.com/transfer-funds-to/123?amount=456`. It also shows how to remedy the problem by validating the input.


    ```python
    import requests
    from flask import Flask, request

    app = Flask(__name__)

    @app.route("/partial_ssrf")
    def partial_ssrf():
        user_id = request.args["user_id"]

        # BAD: user can fully control the path component of the URL
        resp = requests.get("https://api.example.com/user_info/" + user_id)

        if user_id.isalnum():
            # GOOD: user_id is restricted to be alpha-numeric, and cannot alter path component of URL
            resp = requests.get("https://api.example.com/user_info/" + user_id)

    ```

    ## References
    * [OWASP SSRF article](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)
    * [PortSwigger SSRF article](https://portswigger.net/web-security/ssrf)
    * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Security/CWE-943/NoSqlInjection.ql
  relativeBqrsPath: codeql/python-queries/Security/CWE-943/NoSqlInjection.bqrs
  metadata:
    name: NoSQL Injection
    description: |-
      Building a NoSQL query from user-controlled sources is vulnerable to insertion of
                    malicious NoSQL code by the user.
    kind: path-problem
    precision: high
    problem.severity: error
    security-severity: 8.8
    id: py/nosql-injection
    tags: |-
      security
             external/cwe/cwe-943
  queryHelp: |
    # NoSQL Injection
    Passing user-controlled sources into NoSQL queries can result in a NoSQL injection flaw. This tainted NoSQL query containing a user-controlled source can then execute a malicious query in a NoSQL database such as MongoDB. In order for the user-controlled source to taint the NoSQL query, the user-controller source must be converted into a Python object using something like `json.loads` or `xmltodict.parse`.

    Because a user-controlled source is passed into the query, the malicious user can have complete control over the query itself. When the tainted query is executed, the malicious user can commit malicious actions such as bypassing role restrictions or accessing and modifying restricted data in the NoSQL database.


    ## Recommendation
    NoSQL injections can be prevented by escaping user-input's special characters that are passed into the NoSQL query from the user-supplied source. Alternatively, using a sanitize library such as MongoSanitizer will ensure that user-supplied sources can not act as a malicious query.


    ## Example
    In the example below, the user-supplied source is passed to a MongoDB function that queries the MongoDB database.


    ```python
    from flask import Flask, request
    from flask_pymongo import PyMongo
    import json

    mongo = PyMongo(app)


    @app.route("/")
    def home_page():
        unsanitized_search = request.args['search']
        json_search = json.loads(unsanitized_search)

        result = mongo.db.user.find({'name': json_search})

    ```
    This can be fixed by using a sanitizer library like MongoSanitizer as shown in this annotated code version below.


    ```python
    from flask import Flask, request
    from flask_pymongo import PyMongo
    from mongosanitizer.sanitizer import sanitize
    import json

    mongo = PyMongo(app)


    @app.route("/")
    def home_page():
        unsafe_search = request.args['search']
        json_search = json.loads(unsafe_search)
        safe_search = sanitize(unsanitized_search)

        result = client.db.collection.find_one({'data': safe_search})

    ```

    ## References
    * Mongoengine: [Documentation](http://mongoengine.org/).
    * Flask-Mongoengine: [Documentation](http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/).
    * PyMongo: [Documentation](https://pypi.org/project/pymongo/).
    * Flask-PyMongo: [Documentation](https://flask-pymongo.readthedocs.io/en/latest/).
    * OWASP: [NoSQL Injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).
    * Security Stack Exchange Discussion: [Question 83231](https://security.stackexchange.com/questions/83231/mongodb-nosql-injection-in-python-code).
    * Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Summary/LinesOfCode.ql
  relativeBqrsPath: codeql/python-queries/Summary/LinesOfCode.bqrs
  metadata:
    name: Total lines of Python code in the database
    description: |-
      The total number of lines of Python code across all files, including
         external libraries and auto-generated files. This is a useful metric of the size of a
         database. This query counts the lines of code, excluding whitespace or comments.
    kind: metric
    tags: |-
      summary
             telemetry
    id: py/summary/lines-of-code
 -
  pack: codeql/python-queries#0
  relativeQueryPath: Summary/LinesOfUserCode.ql
  relativeBqrsPath: codeql/python-queries/Summary/LinesOfUserCode.bqrs
  metadata:
    name: Total lines of user written Python code in the database
    description: |-
      The total number of lines of Python code from the source code directory,
         excluding auto-generated files. This query counts the lines of code, excluding
         whitespace or comments. Note: If external libraries are included in the codebase
         either in a checked-in virtual environment or as vendored code, that will currently
         be counted as user written code.
    kind: metric
    tags: |-
      summary
             lines-of-code
             debug
    id: py/summary/lines-of-user-code
extensionPacks: []
packs:
  codeql/util#3:
    name: codeql/util
    version: 2.0.17
    isLibrary: true
    isExtensionPack: false
    localPath: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/.codeql/libraries/codeql/util/2.0.17/
    localPackDefinitionFile: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/.codeql/libraries/codeql/util/2.0.17/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
  codeql/python-queries#0:
    name: codeql/python-queries
    version: 1.6.4
    isLibrary: false
    isExtensionPack: false
    localPath: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/
    localPackDefinitionFile: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions:
     -
      pack: codeql/python-all#1
      relativePath: ext/default-threat-models-fixup.model.yml
      index: 0
      firstRowId: 0
      rowCount: 1
      locations:
        lineNumbers: A=8
        columnNumbers: A=9
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Asyncpg.model.yml
      index: 0
      firstRowId: 1
      rowCount: 5
      locations:
        lineNumbers: A=7+1+2+1+2
        columnNumbers: A=9*5
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Asyncpg.model.yml
      index: 1
      firstRowId: 6
      rowCount: 6
      locations:
        lineNumbers: A=20+4+1*2+2+1
        columnNumbers: A=9*6
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Stdlib.model.yml
      index: 0
      firstRowId: 12
      rowCount: 12
      locations:
        lineNumbers: A=6+1*4+2+1+2+1*2+4+2
        columnNumbers: A=9*12
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Stdlib.model.yml
      index: 1
      firstRowId: 24
      rowCount: 1
      locations:
        lineNumbers: A=29
        columnNumbers: A=9
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/Stdlib.model.yml
      index: 2
      firstRowId: 25
      rowCount: 66
      locations:
        lineNumbers: A=37+1+2+4+2*2+4+2*3+1+2+1+2+1+2+4+2+4+2*2+3+2*2+3+1+2*4+4+1+4+1+4+1*5+2*4+4+1+2*11+3+2+3+4+1+2*2+1+2
        columnNumbers: A=9*66
     -
      pack: codeql/python-all#1
      relativePath: semmle/python/frameworks/data/internal/subclass-capture/ALL.model.yml
      index: 0
      firstRowId: 91
      rowCount: 58275
      locations:
        lineNumbers: A=7+3*58274
        columnNumbers: A=5*58275
     -
      pack: codeql/threat-models#2
      relativePath: ext/supported-threat-models.model.yml
      index: 0
      firstRowId: 58366
      rowCount: 1
      locations:
        lineNumbers: A=6
        columnNumbers: A=9
     -
      pack: codeql/threat-models#2
      relativePath: ext/threat-model-grouping.model.yml
      index: 0
      firstRowId: 58367
      rowCount: 15
      locations:
        lineNumbers: A=8+3+1+3+1*5+3+1+5+1*3
        columnNumbers: A=9*15
  codeql/python-all#1:
    name: codeql/python-all
    version: 4.0.14
    isLibrary: true
    isExtensionPack: false
    localPath: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/.codeql/libraries/codeql/python-all/4.0.14/
    localPackDefinitionFile: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/.codeql/libraries/codeql/python-all/4.0.14/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
  codeql/threat-models#2:
    name: codeql/threat-models
    version: 1.0.30
    isLibrary: true
    isExtensionPack: false
    localPath: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/.codeql/libraries/codeql/threat-models/1.0.30/
    localPackDefinitionFile: file:///home/codespace/.codeql/packages/codeql/python-queries/1.6.4/.codeql/libraries/codeql/threat-models/1.0.30/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
